# Hooks/events protocol and schema

This page specifies the **bidirectional communication protocol** between:

- the embedded Cellucid web UI (in the browser), and
- Python code in `cellucid-python` (in the notebook/kernel).

It is the “developer contract” behind:
- `@viewer.on_selection` and friends (frontend → Python),
- `viewer.highlight_cells(...)` and friends (Python → frontend).

If you only need user-facing usage examples, start with:
- {doc}`../e_jupyter_hooks/index`

---

## Two channels, two jobs

### Channel A — Python → frontend (commands)

Transport:
- `window.postMessage(...)` into the iframe

Used for:
- “do something now” commands (highlight, set color-by, reset camera, request session bundle)

Authentication-ish:
- messages include `viewerToken` (the frontend can ignore commands without it)

### Channel B — frontend → Python (events)

Transport:
- HTTP `POST` to `/_cellucid/events` on the data server

Used for:
- “user did something” events (selection, hover, click, ready)

Routing:
- event payload contains `viewerId`
- the server routes by `viewerId` to the correct viewer callback

Important security note:
- the HTTP event endpoint is not currently authenticated beyond `viewerId`.
  Treat it as trusted-local plumbing unless you build additional controls.

---

## Frontend → Python events: transport and routing

### HTTP endpoint

- `POST /_cellucid/events`
- body: JSON

Server implementation:
- `cellucid-python/src/cellucid/_server_base.py` (`CORSMixin.handle_event_post`)

Routing:
- server extracts `viewerId`
- server calls the registered callback for that `viewerId`
- the viewer updates state and triggers hooks

Python implementation:
- `cellucid-python/src/cellucid/jupyter.py`
  - `_register_viewer_for_messages`
  - `BaseViewer._handle_frontend_message`

### Event mapping in Python

The viewer maps:

- frontend `type: "selection"` → hook event `"selection"`
- `hover` → `"hover"`
- `click` → `"click"`
- `ready` → `"ready"`
- any other `type` → uses the raw `type` string as the event name

This is intentionally extensible: adding a new event type on the frontend can “just work” in Python if you don’t need special handling.

---

## Python → frontend commands: transport

Python sends commands by:

1) injecting a JS snippet into the notebook output (`IPython.display.Javascript`)
2) calling `iframe.contentWindow.postMessage(...)`
3) attaching:
   - `viewerId`
   - `viewerToken`

This is implemented in:
- `cellucid-python/src/cellucid/jupyter.py` (`BaseViewer.send_message`)

The set of public command helpers (Python methods) lives in the viewer class (e.g. `highlight_cells`, `set_color_by`, etc.).

---

## Canonical event schemas (what Python code should expect)

The frontend event payload is treated as **loosely-typed JSON**:
- new keys may appear over time,
- Python should ignore unknown keys,
- and should validate “big” fields before using them (e.g. selection arrays).

Below are the expected shapes for core events.

### `ready`

Meaning:
- the viewer finished initial dataset load and is interactive.

Expected keys (typical):
- `datasetId` (string)
- `cellCount` (int)
- possibly UI build metadata

### `selection`

Meaning:
- the user selected a set of cells (lasso, click+shift, neighbor selection, annotation, etc.).

Expected keys:
- `cells`: list[int] (0-based indices in dataset row order)
- `source`: str (selection method; not guaranteed)

### `hover`

Meaning:
- the user is hovering a single cell.

Expected keys:
- `cell`: int (0-based index)

### `click`

Meaning:
- the user clicked a single cell.

Expected keys:
- `cell`: int (0-based index)

### `session_bundle` (Python-side event)

Meaning:
- the server received a `.cellucid-session` upload and is reporting status back to Python.

Expected keys:
- `status`: `"ok"` or `"error"`
- `bytes`: int (if ok)
- `path`: str (temp file path, if ok)
- `error`: str (if error)
- `requestId`: str (correlates with `requestSessionBundle`)

Note:
- this event is generated by the server, not directly by the frontend.

---

## Hook registration semantics (Python)

Python provides a hook registry with two useful patterns:

### Decorator style

```python
@viewer.on_selection
def handle(event):
    print(event["cells"])
```

### “Catch-all” message hook

```python
@viewer.on_message
def handle_any(event):
    # event includes "event": <event_name> plus the payload keys
    print(event)
```

Internals:
- `HookRegistry.trigger` always calls all `message` handlers for any event.

---

## Adding a new event type (developer checklist)

If you add a new event type on the frontend:

1) Ensure the frontend `POST`s a JSON payload to `/_cellucid/events` with:
   - `type: "<your_event_name>"`
   - `viewerId: "<current_viewer_id>"`
2) Decide if Python needs special mapping:
   - If not, Python will use the raw `type` string as the hook name.
   - If yes, update `event_map` in `BaseViewer._handle_frontend_message`.
3) Update docs:
   - add the schema to this page,
   - add user-facing examples in {doc}`../e_jupyter_hooks/index` if appropriate.
4) Add tests if logic is non-trivial.

---

## Edge cases and safety considerations

### Huge selections

Selection payloads can be large (tens/hundreds of thousands of indices).

Developer guidance:
- treat `event["cells"]` as untrusted and potentially huge,
- avoid copying it multiple times,
- consider downsampling for logging and plots.

### Viewer lifecycle and “stale events”

Events are routed by `viewerId`:
- if you re-run a cell and create a new viewer, the old viewer may still be alive,
- ensure you stop old viewers (`viewer.stop()`) to avoid confusion.

### Server exposure

If the server is reachable by others on a network:
- others could POST events to your kernel process (at least causing unexpected hook triggers).

Recommendation:
- do not expose servers publicly; prefer SSH tunnels or trusted internal networks.

---

## Troubleshooting

### Symptom: “I never receive `ready`”

Likely causes:
- dataset load failed in the frontend (check browser console),
- iframe cannot reach server endpoints (proxy/mixed-content),
- server health endpoint fails.

Fix:
- run `viewer.debug_connection()` and follow {doc}`12_debugging_playbook`.

### Symptom: “Events arrive, but `cells` indices are wrong”

Cause:
- indices are positional; you changed row order between “what the UI is showing” and “what Python is indexing”.

Fix:
- keep the same AnnData row order as the server/export,
- or use stable identifiers and explicit mapping for cross-dataset transfer.
